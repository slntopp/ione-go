// Code generated by mockery v1.0.0. DO NOT EDIT.

package arangomock

import context "context"
import driver "github.com/arangodb/go-driver"
import mock "github.com/stretchr/testify/mock"

// User is an autogenerated mock type for the User type
type User struct {
	mock.Mock
}

// AccessibleDatabases provides a mock function with given fields: ctx
func (_m *User) AccessibleDatabases(ctx context.Context) ([]driver.Database, error) {
	ret := _m.Called(ctx)

	var r0 []driver.Database
	if rf, ok := ret.Get(0).(func(context.Context) []driver.Database); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]driver.Database)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Extra provides a mock function with given fields: result
func (_m *User) Extra(result interface{}) error {
	ret := _m.Called(result)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(result)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetCollectionAccess provides a mock function with given fields: ctx, col
func (_m *User) GetCollectionAccess(ctx context.Context, col driver.AccessTarget) (driver.Grant, error) {
	ret := _m.Called(ctx, col)

	var r0 driver.Grant
	if rf, ok := ret.Get(0).(func(context.Context, driver.AccessTarget) driver.Grant); ok {
		r0 = rf(ctx, col)
	} else {
		r0 = ret.Get(0).(driver.Grant)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, driver.AccessTarget) error); ok {
		r1 = rf(ctx, col)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDatabaseAccess provides a mock function with given fields: ctx, db
func (_m *User) GetDatabaseAccess(ctx context.Context, db driver.Database) (driver.Grant, error) {
	ret := _m.Called(ctx, db)

	var r0 driver.Grant
	if rf, ok := ret.Get(0).(func(context.Context, driver.Database) driver.Grant); ok {
		r0 = rf(ctx, db)
	} else {
		r0 = ret.Get(0).(driver.Grant)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, driver.Database) error); ok {
		r1 = rf(ctx, db)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GrantReadWriteAccess provides a mock function with given fields: ctx, db
func (_m *User) GrantReadWriteAccess(ctx context.Context, db driver.Database) error {
	ret := _m.Called(ctx, db)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, driver.Database) error); ok {
		r0 = rf(ctx, db)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IsActive provides a mock function with given fields:
func (_m *User) IsActive() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsPasswordChangeNeeded provides a mock function with given fields:
func (_m *User) IsPasswordChangeNeeded() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Name provides a mock function with given fields:
func (_m *User) Name() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Remove provides a mock function with given fields: ctx
func (_m *User) Remove(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RemoveCollectionAccess provides a mock function with given fields: ctx, col
func (_m *User) RemoveCollectionAccess(ctx context.Context, col driver.AccessTarget) error {
	ret := _m.Called(ctx, col)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, driver.AccessTarget) error); ok {
		r0 = rf(ctx, col)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RemoveDatabaseAccess provides a mock function with given fields: ctx, db
func (_m *User) RemoveDatabaseAccess(ctx context.Context, db driver.Database) error {
	ret := _m.Called(ctx, db)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, driver.Database) error); ok {
		r0 = rf(ctx, db)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Replace provides a mock function with given fields: ctx, options
func (_m *User) Replace(ctx context.Context, options driver.UserOptions) error {
	ret := _m.Called(ctx, options)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, driver.UserOptions) error); ok {
		r0 = rf(ctx, options)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RevokeAccess provides a mock function with given fields: ctx, db
func (_m *User) RevokeAccess(ctx context.Context, db driver.Database) error {
	ret := _m.Called(ctx, db)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, driver.Database) error); ok {
		r0 = rf(ctx, db)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetCollectionAccess provides a mock function with given fields: ctx, col, access
func (_m *User) SetCollectionAccess(ctx context.Context, col driver.AccessTarget, access driver.Grant) error {
	ret := _m.Called(ctx, col, access)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, driver.AccessTarget, driver.Grant) error); ok {
		r0 = rf(ctx, col, access)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetDatabaseAccess provides a mock function with given fields: ctx, db, access
func (_m *User) SetDatabaseAccess(ctx context.Context, db driver.Database, access driver.Grant) error {
	ret := _m.Called(ctx, db, access)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, driver.Database, driver.Grant) error); ok {
		r0 = rf(ctx, db, access)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Update provides a mock function with given fields: ctx, options
func (_m *User) Update(ctx context.Context, options driver.UserOptions) error {
	ret := _m.Called(ctx, options)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, driver.UserOptions) error); ok {
		r0 = rf(ctx, options)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
